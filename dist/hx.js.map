{
  "version": 3,
  "sources": [
    "node_modules/grunt-browserify/node_modules/browser-pack/_prelude.js",
    "js/domNode/componentMOJO.js",
    "js/domNode/cssProperty.js",
    "js/domNode/domNodeFactory.js",
    "js/domNode/queue.js",
    "js/domNode/styleDefinition.js",
    "js/domNode/transitionMOJO.js",
    "js/fn.hx.js",
    "js/hxManager.js",
    "js/main.js",
    "js/pod/animationPod.js",
    "js/pod/bean.js",
    "js/pod/iteratorMOJO.js",
    "js/pod/podFactory.js",
    "js/pod/precisionPod.js",
    "js/pod/promisePod.js",
    "js/pod/subscriberMOJO.js",
    "js/pod/timingMOJO.js",
    "js/shared/bezier.js",
    "js/shared/config.js",
    "js/shared/easing.js",
    "js/shared/helper.js",
    "js/shared/vendorPatch.js",
    "node_modules/bezier-easing/index.js",
    "node_modules/mojo/mojo-0.1.6.min.js",
    "node_modules/wee-promise/dist/wee-promise.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar StyleDefinition = require( 'domNode/styleDefinition' );\nvar CSSProperty = require( 'domNode/cssProperty' );\n\nmodule.exports = ComponentMOJO;\n\nfunction ComponentMOJO() {\n    var that = this;\n    var order = {};\n    MOJO.Construct( that );\n    helper.defProp( that , 'order' , { value: order });\n}\n\nComponentMOJO.prototype = MOJO.Create({\n    getString: function( type ) {\n        var that = this;\n        var order = that.getOrder( type );\n        var arr = order\n            .map(function( key ) {\n                var name = getPropertyName( type , key );\n                var component = that.getComponents( name );\n                component = helper.has( component , 'value' ) ? component.value : component;\n                if ($.hx.preFilter) component = $.hx.preFilter(component);\n                return component.isDefault() ? '' : component.string;\n            })\n            .filter(function( str ) {\n                return str !== '';\n            });\n        return arr.join( ' ' );\n    },\n    getComponents: function( find ) {\n        var that = this;\n        var out = that;\n        if (find) {\n            out = helper.treeSearch( that , find );\n        }\n        if (helper.isUndef( out )) {\n            out = StyleDefinition.isDefined( find ) ? new CSSProperty( find , null ) : {};\n        }\n        return out;\n    },\n    updateComponent: function( bean ) {\n        var that = this;\n        var styles = bean.styles;\n        var type = bean.type;\n        var component = (that[type] = that[type] || {});\n        helper.each( styles , function( property , key ) {\n            var name = getPropertyName( type , key );\n            if (helper.isUndef( component[key] )) {\n                component[key] = new CSSProperty( name , property );\n            }\n            else {\n                component[key].update( property );\n            }\n            if (component[key].isDefault()) {\n                helper.del( component , key );\n                if (helper.length(helper.keys( component )) < 1) {\n                    helper.del( that , type );\n                }\n            }\n        });\n        that._updateOrder( bean );\n    },\n    getOrder: function( type ) {\n        var that = this;\n        var order = that.order;\n        if (type) {\n            return order[type] || [];\n        }\n        return order;\n    },\n    setOrder: function( type , newOrder ) {\n        var that = this;\n        var order = that.order;\n        if (newOrder) {\n            order[type] = newOrder;\n        }\n        else {\n            helper.del( order , type );\n        }\n    },\n    _updateOrder: function( bean ) {  \n        var that = this;\n        var type = bean.type;\n        var storedOrder = that.getOrder( type );\n        var passedOrder = bean.order.passed;\n        var computedOrder = bean.order.computed;\n        var newOrder = passedOrder.concat( storedOrder , computedOrder );\n        var componentKeys = helper.keys( that.getComponents( type ));\n        newOrder = newOrder.filter(function( property , i ) {\n            return (helper.indexOf( newOrder , property ) === i && helper.indexOf( componentKeys , property ) >= 0);\n        });\n        that.setOrder( type , newOrder );\n    }\n});\n\nfunction getPropertyName( type , property ) {\n    return (property === 'value' ? type : property);\n}\n",
    "var helper = require( 'shared/helper' );\nvar StyleDefinition = require( 'domNode/styleDefinition' );\n\nmodule.exports = CSSProperty;\n\nfunction CSSProperty( name , values ) {\n    var that = this;\n    var definition = StyleDefinition.retrieve( name );\n    var isNull;\n    helper.defProps( that , {\n        name: helper.descriptor(function() {\n            return name;\n        }),\n        pName: helper.descriptor(function() {\n            return definition.pName;\n        }),\n        defaults: helper.descriptor(function() {\n            return definition.defaults;\n        }),\n        isNull: helper.descriptor(\n            function() {\n                return isNull;\n            },\n            function( value ) {\n                isNull = value;\n            }\n        ),\n        keymap: helper.descriptor(function() {\n            return definition.keymap;\n        }),\n        string: helper.descriptor(function() {\n            return definition.toString( that );\n        }),\n        length: helper.descriptor(function() {\n            return helper.length(\n                helper.keys( that )\n            );\n        }),\n        values: helper.descriptor(function() {\n            if (helper.length( that ) === 1) {\n                return that[0];\n            }\n            else {\n                var key, obj = {}, keymap = that.keymap;\n                for (var i = 0; i < helper.length( keymap ); i++) {\n                    key = keymap[i];\n                    obj[key] = that[i];\n                }\n                return obj;\n            }\n        })\n    });\n    that.defaults.forEach(function( val , i ) {\n        that[i] = val;\n    });\n    that.update( values );\n}\n\nCSSProperty.prototype = $.extend(helper.create( Array.prototype ), {\n    constructor: CSSProperty,\n    clone: function( cloneDefaults ) {\n        var that = this;\n        var subject = (cloneDefaults ? that.defaults : that.values);\n        return new CSSProperty( that.name , subject );\n    },\n    update: function( values ) {\n        values = (helper.instOf( values , CSSProperty ) && values.isNull ? null : values);\n        var that = this;\n        var keymap = that.keymap;\n        var key, i;\n        that.isNull = (values === null);\n        values = (( values || values === 0 ) ? values : that.defaults );\n        if (!helper.isObj( values )) {\n            values = [ values ];\n        }\n        for (i = 0; i < helper.length( keymap ); i++) {\n            if (helper.isArr( values )) {\n                key = i;\n            }\n            else {\n                key = keymap[i];\n            }\n            if (!helper.isUndef( values[key] )) {\n                that[i] = mergeUpdates( that[i] , values[key] );\n            }\n        }\n        function mergeUpdates( storedVal , newVal ) {\n            /* jshint -W061 */\n            var parts = parseExpression( newVal );\n            return ( parts.op ? eval( storedVal + parts.op + parts.val ) : parts.val );\n        }\n    },\n    isDefault: function() {\n        var that = this;\n        return that.isNull && helper.compareArray( that , that.defaults );\n    }\n});\n\nfunction parseExpression( exp ) {\n    var re = /(\\+|\\-|\\*|\\/|\\%)\\=/;\n    var out = {op: null, val: 0};\n    var match = re.exec( exp );\n    if (match) {\n        out.op = match[1];\n        exp = exp.replace( re , '' );\n    }\n    out.val = exp;\n    if (out.op) {\n        out.val = parseFloat( out.val , 10 );\n    }\n    return out;\n}\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar Queue = require( 'domNode/queue' );\nvar ComponentMOJO = require( 'domNode/componentMOJO' );\nvar TransitionMOJO = require( 'domNode/transitionMOJO' );\nvar CSSProperty = require( 'domNode/cssProperty' );\nvar PropertyMap = require( 'shared/config' ).properties;\nvar Prefix = require( 'shared/vendorPatch' ).prefix;\n\nvar BEAN_START = 'beanStart';\nvar BEAN_COMPLETE = 'beanComplete';\nvar CLUSTER_COMPLETE = 'clusterComplete';\nvar POD_PAUSED = 'podPaused';\nvar POD_RESUMED = 'podResumed';\nvar POD_COMPLETE = 'podComplete';\nvar POD_CANCELED = 'podCanceled';\n\nmodule.exports = DomNodeFactory;\n\nfunction DomNodeFactory( element ) {\n    // if this is already an hx element, return it\n    if (!helper.isUndef( element.$hx )) {\n        return element;\n    }\n    // otherwise, create a new hx element\n    var $hx = new MOJO(getBoundModule( hxModule , element ));\n    $hx.queue = new Queue();\n    $hx.componentMOJO = new ComponentMOJO();\n    $hx.transitionMOJO = new TransitionMOJO();\n    element.$hx = $hx;\n    return element;\n}\n\nvar hxModule = {\n    paint: function( typeArray ) {\n        var that = this;\n        var $hx = that.$hx;\n        var style = {};\n        if (helper.isUndef( typeArray )) {\n            typeArray = helper.keys( $hx.getOrder() );\n        }\n        else {\n            typeArray = helper.ensureArray( typeArray );\n        }\n        typeArray.forEach(function( type ) {\n            var property = Prefix( type );\n            var string = $hx.getStyleString( type );\n            style[property] = string;\n        });\n        $(that).css( style );\n    },\n    handleMOJO: function( e ) {\n        var that = this;\n        var $hx = that.$hx;\n        var args = arguments;\n        var type, bean, pod;\n        switch (e.type) {\n            case BEAN_START:\n                bean = args[1];\n                $(that).trigger( 'hx.start' , {\n                    ref: bean.ref,\n                    bean: bean.seed\n                });\n            break;\n            case BEAN_COMPLETE:\n                bean = args[1];\n                $(that).trigger( 'hx.end' , {\n                    ref: bean.ref,\n                    bean: bean.seed\n                });\n                bean.options.done();\n            break;\n            case CLUSTER_COMPLETE:\n                type = args[1];\n                $hx.deleteTransition( type );\n                $hx.applyTransition();\n            break;\n            case POD_PAUSED:\n            case POD_RESUMED:\n                var evtString = ('hx.' + (e.type === POD_PAUSED ? 'pause' : 'resume'));\n                pod = args[1];\n                $(that).trigger( evtString , {\n                    progress: pod.progress\n                });\n            break;\n            case POD_COMPLETE:\n                pod = args[1];\n                pod.dispel( POD_COMPLETE , $hx );\n                $hx.proceed();\n            break;\n            case POD_CANCELED:\n                pod = args[1];\n                if (pod.type === 'promise') {\n                    pod.dispel( POD_COMPLETE );\n                }\n                else {\n                    pod.dispel( POD_COMPLETE , $hx );\n                    pod.once( POD_COMPLETE , function() {\n                        if (!$hx.getPodCount( 'animation' )) {\n                            $hx.resetTransition();\n                            $hx.applyTransition();\n                        }\n                    });\n                }\n            break;\n        }\n    },\n    setTransition: function( bean ) {\n        this.$hx.transitionMOJO.setTransition( bean );\n    },\n    deleteTransition: function( type ) {\n        this.$hx.transitionMOJO.deleteTransition( type );\n    },\n    resetTransition: function() {\n        var transitionMOJO = this.$hx.transitionMOJO;\n        helper.each( transitionMOJO , function( val , type ) {\n            transitionMOJO.deleteTransition( type );\n        });\n    },\n    applyTransition: function() {\n        var that = this;\n        var property = Prefix( 'transition' );\n        var string = that.$hx.getTransitionString();\n        if (that.style.transition === string) {\n            return;\n        }\n        $(that).css( property , string );\n    },\n    getComponents: function( find , pretty ) {\n        find = PropertyMap[find] || find;\n        pretty = (!helper.isUndef( pretty ) ? pretty : true);\n        var $hx = this.$hx;\n        var components = $hx.componentMOJO.getComponents( find );\n        var out = {};\n        if (helper.instOf( components , ComponentMOJO )) {\n            components.each(function( styleObj , key ) {\n                out[key] = $hx.getComponents( key , pretty );\n            });\n        }\n        else if (helper.instOf( components , CSSProperty )) {\n            out = getProperty( components );\n        }\n        else if (!helper.isUndef( components )) {\n            helper.each( components , function( property , key ) {\n                key = getKey( key );\n                property = getProperty( property );\n                if (key === 'value') {\n                    out = property;\n                }\n                else {\n                    out[key] = property;\n                }\n            });\n        }\n        function getProperty( property ) {\n            return (pretty ? property.values : property.clone());\n        }\n        function getKey( key ) {\n            return (pretty ? (PropertyMap.inverse[ key ] || key) : key);\n        }\n        return out;\n    },\n    getOrder: function( type ) {\n        return this.$hx.componentMOJO.getOrder( type );\n    },\n    updateComponent: function( bean ) {\n        this.$hx.componentMOJO.updateComponent( bean );\n    },\n    resetComponents: function( type ) {\n        var componentMOJO = this.$hx.componentMOJO;\n        if (type) {\n            componentMOJO.remove( type );\n        }\n        else {\n            componentMOJO.each(function( val , key ) {\n                componentMOJO.remove( key );\n            });\n        }\n    },\n    getStyleString: function( type ) {\n        return this.$hx.componentMOJO.getString( type );\n    },\n    getTransitionString: function() {\n        return this.$hx.transitionMOJO.getString();\n    },\n    addPod: function( pod ) {\n        var $hx = this.$hx;\n        var evt = [\n            BEAN_START,\n            BEAN_COMPLETE,\n            CLUSTER_COMPLETE,\n            POD_PAUSED,\n            POD_RESUMED,\n            POD_COMPLETE,\n            POD_CANCELED\n        ];\n        pod.when( evt , $hx );\n        $hx.queue.pushPod( pod );\n    },\n    proceed: function() {\n        return this.$hx.queue.proceed();\n    },\n    clearQueue: function( all ) {\n        this.$hx.queue.clear( all );\n    },\n    getCurrentPod: function() {\n        return this.$hx.queue[0] || false;\n    },\n    getPodCount: function( type ) {\n        return this.$hx.queue.getPodCount( type );\n    },\n    cleanup: function() {\n        delete this.$hx;\n    }\n};\n\n\nfunction getBoundModule( module , context ) {\n    var scope = {}, func;\n    for (var key in module) {\n        func = module[key];\n        scope[key] = func.bind( context );\n    }\n    return scope;\n}\n",
    "var helper = require( 'shared/helper' );\n\nmodule.exports = Queue;\n\nfunction Queue() {\n    var that = this;\n    Array.call( that );\n    helper.defProps( that , {\n        complete: helper.descriptor(function() {\n            return !length( that );\n        })\n    });\n}\n\nQueue.prototype = $.extend(helper.create( Array.prototype ), {\n    constructor: Queue,\n    run: function() {\n        var pod = this[0];\n        if (pod) {\n            pod.run();\n        }\n    },\n    pushPod: function( pod ) {\n        var that = this;\n        that.push( pod );\n        if (length( that ) === 1) {\n            that.run();\n        }\n    },\n    proceed: function() {\n        var that = this;\n        that.shift();\n        if (!that.complete) {\n            that.run();\n            return true;\n        }\n        return false;\n    },\n    clear: function( all ) {\n        // all controls whether all pods or all but the current pod will be cleared\n        all = (!helper.isUndef( all ) ? all : true);\n        var that = this;\n        while (length( that ) > (all ? 0 : 1)) {\n            that.pop().cancel();\n        }\n    },\n    getPodCount: function( type ) {\n        type = helper.ensureArray( type );\n        return length(\n            this.filter(function( pod ) {\n                return helper.indexOf( type , pod.type ) >= 0;\n            })\n        );\n    }\n});\n\n/*\n**  iOS encounters a strange issue using Helper.length\n**  (but not this length function), mainly in Queue.prototype.clear,\n**  where pods are removed from the queue and cancelled,\n**  but length( queue ) continues to return the same value.\n**  It's inconsistent and difficult to reproduce, so fixing\n**  for now by adding this length function in the same context.\n*/\n\nfunction length( subject ) {\n    return subject.length;\n}\n",
    "var helper = require( 'shared/helper' );\nvar PropertyMap = require( 'shared/config' ).properties;\n\nmodule.exports = StyleDefinition;\n\nfunction StyleDefinition() {\n    var that = this;\n    var args = arguments;\n    var other = Properties.other;\n    that.name = helper.shift( args );\n    that.pName = args[0] || that.name;\n    that.defaults = other.defaults;\n    that.keymap = other.keymap;\n    that.stringGetter = function( name , CSSProperty ) {\n        return CSSProperty[0];\n    };\n}\n\nStyleDefinition.define = function() {\n    var args = arguments;\n    var name = helper.pop( args );\n    var prettyName = args[0] || name;\n    if (Properties[name]) {\n        throw new Error( name + ' is already defined' );\n    }\n    if (name !== prettyName) {\n        PropertyMap[prettyName] = name;\n    }\n    Properties[name] = new StyleDefinition( name , prettyName );\n    return Properties[name];\n};\n\nStyleDefinition.isDefined = function( name ) {\n    return !helper.isUndef( Properties[name] );\n};\n\nStyleDefinition.retrieve = function( name ) {\n    return Properties[name] || new StyleDefinition( name );\n};\n\nStyleDefinition.prototype = {\n    constructor: StyleDefinition,\n    set: function( key , value ) {\n        var that = this;\n        if (key === 'defaults' || key === 'keymap') {\n            value = helper.ensureArray( value );\n        }\n        that[key] = value;\n        return that;\n    },\n    toString: function( CSSProperty ) {\n        return this.stringGetter( CSSProperty.name , CSSProperty );\n    }\n};\n\nvar Properties = {\n    other: {\n        defaults: [ '' ],\n        keymap: [ 0 ]\n    }\n};\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar VendorPatch = require( 'shared/vendorPatch' );\nvar Easing = require( 'shared/easing' );\n\nmodule.exports = TransitionMOJO;\n\nfunction TransitionMOJO() {\n    MOJO.Construct( this );\n}\n\nTransitionMOJO.prototype = MOJO.Create({\n    constructor: TransitionMOJO,\n    getString: function() {\n        var that = this;\n        var arr = [];\n        helper.each( that , function( options , type ) {\n            var duration = options.duration;\n            var easing = options.easing;\n            //var delay = options.delay;\n            var str = getTransitionString( type , duration , easing , 0 );\n            arr.push( str );\n        });\n        return VendorPatch.prefix(\n            arr.join( ', ' )\n        );\n    },\n    setTransition: function( bean ) {\n        this.set( bean.type , getTransitionObject( bean ));\n    },\n    deleteTransition: function( type ) {\n        this.remove( type );\n    }\n});\n\nfunction getTransitionObject( bean ) {\n    var options = bean.options;\n    return {\n        duration: options.duration,\n        easing: Easing( options.easing ).string\n        //delay: options.delay\n    };\n}\n\nfunction getTransitionString( type , duration , easing , delay ) {\n    return (type + ' ' + duration + 'ms ' + easing + ' ' + delay + 'ms');\n}\n",
    "var hxManager = require( 'hxManager' );\nvar helper = require( 'shared/helper' );\n\nmodule.exports = function() {\n    var args = arguments;\n    var hxm = new hxManager( this );\n    var out;\n    if (helper.is( args[0] , 'string' )) {\n        var method = helper.shift( args );\n        if (!helper.isFunc( hxm[method] )) {\n            throw new Error( method + ' is not a function.' );\n        }\n        out = hxm[method].apply( hxm , args );\n    }\n    else if (helper.is( args[0] , 'object' )) {\n        out = hxm.animate( args[0] );\n    }\n    else {\n        out = hxm;\n    }\n    return out;\n};\n",
    "var Promise = require( 'wee-promise' );\nvar helper = require( 'shared/helper' );\nvar DomNodeFactory = require( 'domNode/domNodeFactory' );\nvar PodFactory = require( 'pod/podFactory' );\nvar Bean = require( 'pod/bean' );\nvar IteratorMOJO = require( 'pod/iteratorMOJO' );\n\nmodule.exports = hxManager;\n\nfunction hxManager( j ){\n    var that = this;\n    if (helper.instOf( j , hxManager )) {\n        return j;\n    }\n    j.each(function( i ) {\n        that[i] = DomNodeFactory( j[i] );\n    });\n    helper.defProp( that , 'length' , helper.descriptor(\n        function() {\n            return helper.length( j );\n        }\n    ));\n    return that;\n}\n\nhxManager.prototype = $.extend(helper.create( $.prototype ), {\n    animate: function( bundle ) {\n        var that = this;\n        return eachNode( that , function( $hx , node , i ) {\n            var pod = PodFactory( node , 'animation' );\n            helper.ensureArray( bundle ).forEach(function( seed ) {\n                if (helper.isFunc( seed )) {\n                    pod.addCallback(seed.bind( that ));\n                }\n                else {\n                    var bean = new Bean( seed , node , i );\n                    pod.addBean( bean );\n                }\n            });\n            $hx.addPod( pod );\n        });\n    },\n    iterate: function( bundle ) {\n        var that = this;\n        return eachNode( that , function( $hx , node , i ) {\n            var pod = PodFactory( node , 'precision' );\n            helper.ensureArray( bundle ).forEach(function( seed ) {\n                if (helper.isFunc( seed )) {\n                    pod.addCallback(seed.bind( that ));\n                }\n                else {\n                    var bean = new Bean( seed , node , i );\n                    var iterator = new IteratorMOJO( node , bean );\n                    pod.addBean( iterator );\n                }\n            });\n            $hx.addPod( pod );\n        });\n    },\n    promise: function( func , method ) {\n        method = method || 'all';\n        var that = this;\n        var pods = that.toArray().map(function( node ) {\n            var $hx = node.$hx;\n            var pod = PodFactory( node , 'promise' );\n            $hx.addPod( pod );\n            return pod;\n        });\n        Promise[ method ]( pods ).then(function() {\n            new Promise(\n                // create the macroPromise\n                func.bind( that )\n            )\n            .then(function() {\n                // if the macroPromise is resolved, resolve the pods\n                pods.forEach(function( pod ) {\n                    pod.resolvePod();\n                });\n            })\n            .catch(function( err ) {\n                // otherwise, clear the queue so we can start again\n                that\n                .clear()\n                .trigger( 'hx.reject' , arguments );\n                if (helper.instOf( err , Error )) {\n                    $.hx.error( err );\n                    $(document).trigger( 'hx.error' , err );\n                }\n            });\n        });\n        return that;\n    },\n    pause: function() {\n        return this._precAction( 'pause' );\n    },\n    resume: function() {\n        return this._precAction( 'resume' );\n    },\n    _precAction: function( method , attempts ) {\n        attempts = attempts || 0;\n        var that = this;\n        var pods = that.toArray()\n            .map(function( node ) {\n                return node.$hx.getCurrentPod();\n            })\n            .filter(function( pod ) {\n                return pod.type === 'precision';\n            });\n        if (helper.length( pods ) !== helper.length( that ) && attempts < 10) {\n            var unsubscribe = $.hx.subscribe(function() {\n                attempts++;\n                unsubscribe();\n                that._precAction( method , attempts );\n            });\n        }\n        else {\n            pods.forEach(function( pod ) {\n                pod[ method ]();\n            });\n        }\n        return that;\n    },\n    paint: function( type ) {            \n        return eachNode( this , function( $hx ) {\n            $hx.paint( type );\n        });\n    },\n    reset: function( type ) {\n        return eachNode( this , function( $hx ) {\n            $hx.resetComponents( type );\n        });\n    },\n    then: function( func ) {\n        return this.promise( func );\n    },\n    race: function( func ) {\n        return this.promise( func , 'race' );\n    },\n    defer: function( time ) {\n        return this.promise(function( resolve ) {\n            if (time) {\n                var unsubscribe = $.hx.subscribe(function( elapsed ) {\n                    if (elapsed >= time) {\n                        unsubscribe();\n                        resolve();\n                    }\n                });\n            }\n        });\n    },\n    update: function( bundle ) {\n        // update a node's components without applying the transition\n        var that = this;\n        helper.ensureArray( bundle ).forEach(function( seed ) {\n            eachNode( that , function( $hx , node , i ) {\n                var bean = new Bean( seed , node , i );\n                $hx.updateComponent( bean );\n            });\n        });\n        return that;\n    },\n    resolve: function( all ) {\n        // all controls whether all pod types or only promise pods will be resolved\n        all = (!helper.isUndef( all ) ? all : false);\n        // force resolve the current pod in each queue\n        return eachNode( this , function( $hx ) {\n            var pod = $hx.getCurrentPod();\n            if (pod && (all || (!all && pod.type === 'promise'))) {\n                pod.resolvePod();\n            }\n        });\n    },\n    detach: function() {\n        // detach callbacks from the subscriber module,\n        // but still allow the pod to continue running\n        return eachNode( this , function( $hx ) {\n            var pod = $hx.getCurrentPod();\n            if (pod) {\n                pod.detach();\n            }\n        });\n    },\n    clear: function() {\n        // clear all pods in each queue\n        return eachNode( this , function( $hx ) {\n            $hx.clearQueue();\n        });\n    },\n    break: function() {\n        var that = this;\n        // clear all but the current pod in each queue\n        eachNode( that , function( $hx ) {\n            $hx.clearQueue( false );\n        });\n        // resolve any remaining promise pods\n        return that.resolve();\n    },\n    zero: function( hxArgs ) {\n        var that = this;\n        // update the stored components\n        that.update( hxArgs );\n        // remove any stored transitions\n        eachNode( that , function( $hx ) {\n            $hx.resetTransition();\n            $hx.applyTransition();\n        });\n        // run paint\n        return that.paint();\n    },\n    done: function( func ) {\n        var that = this;\n        that.promise(function( resolve ) {\n            (func || function() {}).call( that );\n            resolve();\n        });\n    },\n    get: function( find , pretty ) {\n        return this.toArray().map(function( node ) {\n            return node.$hx.getComponents( find , pretty );\n        });\n    },\n    cleanup: function() {\n        eachNode( this , function( $hx ) {\n            $hx.cleanup();\n        });\n    }\n});\n\nfunction eachNode( hxm , callback ) {\n    hxm.toArray().forEach(function( node , i ) {\n        callback( node.$hx , node , i );\n    });\n    return hxm;\n}\n",
    "var helper = require( 'shared/helper' );\nvar VendorPatch = require( 'shared/vendorPatch' );\nvar StyleDefinition = require( 'domNode/styleDefinition' );\nvar Bezier = require( 'shared/bezier' );\nvar Easing = require( 'shared/easing' );\nvar TimingMOJO = require( 'pod/timingMOJO' );\nvar hxManager = require( 'hxManager' );\nvar hx = require( 'fn.hx' );\n\n// Do some important stuff when hx is loaded\nmodule.exports = hxManager;\nwindow.hxManager = hxManager;\nhxManager.Easing = Easing;\nhxManager.VendorPatch = VendorPatch;\nhxManager.StyleDefinition = StyleDefinition;\n$.fn.hx = hx;\n$.hx = {\n    defineProperty: StyleDefinition.define,\n    defineBezier: Bezier.define,\n    subscribe: function( callback ) {\n        var startTime = null;\n        TimingMOJO.subscribe( timingCallback );\n        function timingCallback( e , timestamp ) {\n            startTime = (startTime === null ? timestamp : startTime);\n            callback(( timestamp - startTime ));\n        }\n        return function() {\n            TimingMOJO.unsubscribe( timingCallback );\n        };\n    },\n    error: function( error ) {\n        try { console.error( error.stack ); }\n        catch( err ) {}\n    }\n};\n\n// define a bunch of properties\n[\n    [\n        [ 'matrix' , 'matrix3d' ],\n        [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ],\n        [ 'a1', 'b1', 'c1', 'd1', 'a2', 'b2', 'c2', 'd2', 'a3', 'b3', 'c3', 'd3', 'a4', 'b4', 'c4', 'd4' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( ',' ) + ')';\n        }\n    ],\n    [\n        [ 'translate' , 'translate3d' ],\n        [ 0 , 0 , 0 ],\n        [ 'x' , 'y' , 'z' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( 'px,' ) + 'px)';\n        }\n    ],\n    [\n        [ 'scale' , 'scale3d' ],\n        [ 1 , 1 , 1 ],\n        [ 'x' , 'y' , 'z' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( ',' ) + ')';\n        }\n    ],\n    [\n        [ 'rotate' , 'rotate3d' ],\n        [ 0 , 0 , 0 , 0 ],\n        [ 'x' , 'y' , 'z' , 'a' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( ',' ) + 'deg)';\n        }\n    ],\n    [\n        [ 'rotateX' ],\n        0,\n        null,\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty[0] + 'deg)';\n        }\n    ],\n    [\n        [ 'rotateY' ],\n        0,\n        null,\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty[0] + 'deg)';\n        }\n    ],\n    [\n        [ 'rotateZ' ],\n        0,\n        null,\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty[0] + 'deg)';\n        }\n    ],\n    [\n        [ 'matrix2d' , 'matrix' ],\n        [ 1 , 0 , 0 , 1 , 0 , 0 ],\n        [ 'a1' , 'b1' , 'c1' , 'd1' , 'a4' , 'b4' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( ',' ) + ')';\n        }\n    ],\n    [\n        [ 'translate2d' , 'translate' ],\n        [ 0 , 0 ],\n        [ 'x' , 'y' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( 'px,' ) + 'px)';\n        }\n    ],\n    [\n        [ 'scale2d' , 'scale' ],\n        [ 1 , 1 ],\n        [ 'x' , 'y' ],\n        function( name , CSSProperty ) {\n            return name + '(' + CSSProperty.join( ',' ) + ')';\n        }\n    ],\n    [\n        [ 'opacity' ],\n        1,\n        null,\n        null\n    ]\n]\n.forEach(function( definition ) {\n    var property = StyleDefinition.define.apply( null , definition[0] );\n    [\n        'defaults',\n        'keymap',\n        'stringGetter'\n    ]\n    .forEach(function( key , i ) {\n        var args = definition[i+1];\n        if (args !== null) {\n            property.set( key , args );\n        }\n    });\n});\n\n\n/*\n**  Derived from AliceJS easing definitions\n**  http://blackberry.github.io/Alice/\n*/\nvar beziers = {\n    linear: [ 0.25 , 0.25 , 0.75 , 0.75 ],\n    ease: [ 0.25 , 0.1 , 0.25 , 1 ],\n    'ease-in': [ 0.42 , 0 , 1 , 1 ],\n    'ease-out': [ 0 , 0 , 0.58 , 1 ],\n    'ease-in-out': [ 0.42 , 0 , 0.58 , 1 ],\n    easeInQuad: [ 0.55 , 0.085 , 0.68 , 0.53 ],\n    easeInCubic: [ 0.55 , 0.055 , 0.675 , 0.19 ],\n    easeInQuart: [ 0.895 , 0.03 , 0.685 , 0.22 ],\n    easeInQuint: [ 0.755 , 0.05 , 0.855 , 0.06 ],\n    easeInSine: [ 0.47 , 0 , 0.745 , 0.715 ],\n    easeInExpo: [ 0.95 , 0.05 , 0.795 , 0.035 ],\n    easeInCirc: [ 0.6 , 0.04 , 0.98 , 0.335 ],\n    easeInBack: [ 0.6 , -0.28 , 0.735 , 0.045 ],\n    easeOutQuad: [ 0.25 , 0.46 , 0.45 , 0.94 ],\n    easeOutCubic: [ 0.215 , 0.61 , 0.355 , 1 ],\n    easeOutQuart: [ 0.165 , 0.84 , 0.44 , 1 ],\n    easeOutQuint: [ 0.23 , 1 , 0.32 , 1 ],\n    easeOutSine: [ 0.39 , 0.575 , 0.565 , 1 ],\n    easeOutExpo: [ 0.19 , 1 , 0.22 , 1 ],\n    easeOutCirc: [ 0.075 , 0.82 , 0.165 , 1 ],\n    easeOutBack: [ 0.175 , 0.885 , 0.32 , 1.275 ],\n    easeInOutQuad: [ 0.455 , 0.03 , 0.515 , 0.955 ],\n    easeInOutCubic: [ 0.645 , 0.045 , 0.355 , 1 ],\n    easeInOutQuart: [ 0.77 , 0 , 0.175 , 1 ],\n    easeInOutQuint: [ 0.86 , 0 , 0.07 , 1 ],\n    easeInOutSine: [ 0.445 , 0.05 , 0.55 , 0.95 ],\n    easeInOutExpo: [ 1 , 0 , 0 , 1 ],\n    easeInOutCirc: [ 0.785 , 0.135 , 0.15 , 0.86 ],\n    easeInOutBack: [ 0.68 , -0.55 , 0.265 , 1.55 ],\n    easeOutBackMod1: [ 0.7 , -1 , 0.5 , 2 ],\n    easeMod1: [ 0.25 , 0.2 , 0.25 , 1 ],\n    gravityUp: [ 0.05 , 0.6 , 0.3 , 1 ],\n    gravityDown: [ 0.65 , 0.01 , 0.78 , 0.5 ]\n};\n\nhelper.each( beziers , function( points , name ) {\n    Bezier.define( name , points );\n});\n\n$(document).trigger( 'hx.ready' );\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar SubscriberMOJO = require( 'pod/subscriberMOJO' );\n\nvar TIMING = 'timing';\nvar TIMING_CALLBACK = 'timingCallback';\nvar POD_COMPLETE = 'podComplete';\nvar POD_CANCELED = 'podCanceled';\nvar POD_FORCED = 'forceResolve';\nvar SUBSCRIBE = 'subscribe';\nvar BEAN_START = 'beanStart';\nvar BEAN_PAINT = 'beanPaint';\nvar BEAN_COMPLETE = 'beanComplete';\nvar CLUSTER_COMPLETE = 'clusterComplete';\nvar PROGRESS = 'progress';\n\nmodule.exports = AnimationPod;\n\nfunction AnimationPod( node ) {\n    var that = this;\n    that.type = AnimationPod.type;\n    that.node = node;\n    that.beans = {};\n    that.forced = false;\n    that.paused = false;\n    that.buffer = 0;\n    that.attached = true;\n    that[PROGRESS] = [];\n    MOJO.Construct( that );\n    helper.defProps( that , {\n        sequence: helper.descriptor(function() {\n            var sequence = {};\n            helper.each( that.beans , function( cluster , type ) {\n                if (helper.length( cluster ) > 0) {\n                    sequence[type] = cluster[0];\n                }\n            });\n            return sequence;\n        }),\n        subscribers: helper.descriptor(function() {\n            return helper.length( that.handlers[ TIMING ] || [] );\n        }),\n        complete: helper.descriptor(function() {\n            return that.subscribers === 0;\n        })\n    });\n    that._init();\n}\n\nAnimationPod.type = 'animation';\n\nAnimationPod.prototype = MOJO.Create({\n    constructor: AnimationPod,\n    _init: function() {\n        var that = this;\n        var subscriber = new SubscriberMOJO();\n        subscriber.when( TIMING , that );\n        that.once([ SUBSCRIBE , POD_COMPLETE , POD_FORCED , POD_CANCELED ] , subscriber , that );\n    },\n    addBean: function( bean ) {\n        var that = this;\n        var type = bean.type;\n        that._getBeans( type ).push( bean );\n        var index = that.subscribers;\n        that.when( TIMING , bean );\n        bean.when( PROGRESS , index , that );\n        bean.once([ BEAN_START , BEAN_COMPLETE ] , that );\n    },\n    addCallback: function( callback ) {  \n        var that = this;\n        that.when( TIMING_CALLBACK , function( e , elapsed , diff , attached ) {\n            if (attached) {\n                callback( elapsed , that.progress );\n            }\n        });\n    },\n    run: function() {\n        var that = this;\n        that.happen( SUBSCRIBE );\n        that._runSequence();\n    },\n    detach: function() {\n        this.attached = false;\n    },\n    _runSequence: function() {\n        var that = this;\n        var $hx = that.node.$hx;\n        helper.each( that.sequence , function( bean , type ) {\n            if (bean.run( $hx )) {\n                bean.once( BEAN_PAINT , function( e ) {\n                    $hx.applyTransition();\n                    $hx.paint( bean.type );\n                });\n            }\n        });\n    },\n    _next: function( type ) {\n        var that = this;\n        var cluster = that._getBeans( type );\n        cluster.shift();\n        return helper.length( cluster ) > 0;\n    },\n    _getBeans: function( type ) {\n        var that = this;\n        var beans = that.beans;\n        var out;\n        if (type) {\n            out = (beans[type] = beans[type] || []);\n        }\n        else {\n            out = beans;\n        }\n        return out;\n    },\n    resolvePod: function() {\n        var that = this;\n        if (that.complete) {\n            that.happen( POD_COMPLETE , that );\n        }\n        else {\n            that.happen( POD_FORCED );\n        }\n    },\n    _resolveBeans: function( type ) {\n        var that = this;\n        that._getBeans( type ).forEach(function( bean ) {\n            that.dispel( null , bean );\n        });\n    },\n    cancel: function() {\n        var that = this;\n        that.happen( POD_CANCELED , that );\n    },\n    handleMOJO: function( e ) {\n        var that = this;\n        var args = arguments;\n        var subscriber, index, progress, bean, type;\n        switch (e.type) {\n            case TIMING:\n                that._timing.apply( that , args );\n            break;\n            case SUBSCRIBE:\n                subscriber = args[1];\n                subscriber.subscribe();\n            break;\n            case POD_COMPLETE:\n                subscriber = args[1];\n                subscriber.dispel();\n                that.dispel();\n            break;\n            case POD_CANCELED:\n                that.dispel([ CLUSTER_COMPLETE , BEAN_COMPLETE ]);\n                that.happen( POD_FORCED );\n            break;\n            case POD_FORCED:\n                that.forced = true;\n                subscriber = args[1];\n                if (!that.attached) {\n                    that.happen( POD_COMPLETE , that );\n                }\n                else {\n                    that.dispel( null , that );\n                    that.happen( POD_COMPLETE , that );\n                    that.once( POD_COMPLETE , subscriber , that );\n                }\n            break;\n            case PROGRESS:\n                index = args[1];\n                progress = args[2];\n                that[PROGRESS][index] = progress > 1 ? 1 : progress;\n            break;\n            case BEAN_START:\n                bean = e.target;\n                that.happen( BEAN_START, bean );\n            break;\n            case BEAN_COMPLETE:\n                bean = e.target;\n                type = bean.type;\n                that.dispel( null , bean );\n                if (!that.forced && that._next( type )) {\n                    that._runSequence();\n                }\n                else if (!that.forced) {\n                    that.happen( CLUSTER_COMPLETE , type );\n                }\n                // trigger beanComplete after clusterComplete so transition\n                // is reset before bean done function is executed\n                if (!that.forced) {\n                    that.happen( BEAN_COMPLETE , bean );\n                }\n                else {\n                    that._resolveBeans( type );\n                }\n                if (that.complete) {\n                    that.resolvePod();\n                }\n            break;\n        }\n    },\n    _timing: function( e , elapsed , diff ) {\n        var that = this;\n        var attached = that.attached;\n        if (that.paused) {\n            that.buffer += diff;\n        }\n        else {\n            that.happen([ TIMING , TIMING_CALLBACK ] , [( elapsed - that.buffer ) , diff , attached ]);\n        }\n    }\n});\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar Config = require( 'shared/config' );\n\nvar TOLERANCE = ( 1000 / 240 );\nvar TIMING = 'timing';\nvar PROGRESS = 'progress';\nvar BEAN_START = 'beanStart';\nvar BEAN_PAINT = 'beanPaint';\nvar BEAN_COMPLETE = 'beanComplete';\n\nvar OptionKeys = Config.optionKeys;\nvar PropertyMap = Config.properties;\nvar Buffer = Config.buffer;\n\nmodule.exports = Bean;\n\nfunction Bean( seed , node , index ) {\n    if (!seed.type) {\n        throw new Error( 'Bean type is required.' );\n    }\n    var that = this;\n    that.running = false;\n    that.buffer = 0;\n    that.progress = 0;\n    MOJO.Construct( that );\n    $.extend( that , getCompiledData( seed , node , index ));\n}\n\nvar Calc = (\n    Bean.Calc = function( elapsed , duration , delay ) {\n        elapsed = elapsed - delay;\n        elapsed = elapsed < 0 ? 0 : elapsed;\n        return (elapsed / (duration ? duration + Buffer : 1));\n    }\n);\n\n\nvar CheckTol = (\n    Bean.CheckTol = function( current , target , duration , delay ) {\n        return (target - current) <= (TOLERANCE / (duration + delay + Buffer));\n    }\n);\n\nBean.prototype = MOJO.Create({\n    constructor: Bean,\n    run: function( $hx ) {\n        var that = this;\n        if (that.running) {\n            return false;\n        }\n        that.running = true;\n        that.when( PROGRESS , that );\n        that.once( BEAN_PAINT , $hx , that );\n        that.happen( BEAN_START );\n        return true;\n    },\n    handleMOJO: function( e ) {\n        var that = this;\n        var args = arguments;\n        var progress, $hx;\n        switch (e.type) {\n            case TIMING:\n                that._timing.apply( that , args );\n            break;\n            case PROGRESS:\n                progress = args[1];\n                if (that.running && progress > 0) {\n                    that.dispel( PROGRESS , that );\n                    that.happen( BEAN_PAINT );\n                }\n            break;\n            case BEAN_PAINT:\n                $hx = args[1];\n                $hx.setTransition( that );\n                $hx.updateComponent( that );\n            break;\n        }\n    },\n    _timing: function( e , elapsed , diff ) {\n        var that = this;\n        var duration = that.options.duration;\n        var delay = that.options.delay;\n        if (!that.running) {\n            that.buffer += diff;\n        }\n        var progress = Calc(( elapsed - that.buffer) , duration , delay );\n        if (CheckTol( progress , 1 , duration , delay )) {\n            progress = 1;\n        }\n        that.happen( PROGRESS , progress );\n        if (progress === 1) {\n            that.happen( BEAN_COMPLETE );\n        }\n    },\n    getOrder: getOrder,\n    getOptions: getOptions,\n    getStyles: getStyles\n});\n\nfunction getOrder( seed ) {\n    var passed = (seed.order || []).map( mapCallback );\n    var computed = helper.keys( seed )\n        .filter(function( key , i ) {\n            return helper.indexOf( OptionKeys , key ) < 0;\n        })\n        .map( mapCallback );\n    function mapCallback( key ) {\n        return PropertyMap[key] || key;\n    }\n    return {\n        passed: passed,\n        computed: computed\n    };\n}\n\nfunction getOptions( seed , node , index ) {\n    var defaults = Config.defaults;\n    var options = $.extend( {} , defaults , seed );\n    helper.each( options , function( val , key ) {\n        if (!helper.has( defaults , key )) {\n            helper.del( options , key );\n        }\n        else if (key === 'done') {\n            // make sure we don't execute the done function just yet\n            options[key] = val.bind( null , node , index );\n        }\n        else {\n            options[key] = getBeanProperty( val , node , index );\n        }\n    });\n    return options;\n}\n\nfunction getStyles( seed , node , index ) {\n    var styles = {};\n    helper.each( seed , function( val , key ) {\n        var mappedKey = PropertyMap[key] || key;\n        if (helper.indexOf( OptionKeys , mappedKey ) < 0) {\n            styles[mappedKey] = getBeanProperty( val , node , index );\n        }\n    });\n    return styles;\n}\n\nfunction getBeanProperty( property , node , index ) {\n    return (helper.isFunc( property ) ? property( node , index ) : property);\n}\n\n\nfunction getCompiledData( seed , node , index ) {\n    var options = getOptions( seed , node , index );\n    return {\n        ref: options.ref,\n        seed: seed,\n        type: seed.type,\n        order: getOrder( seed ),\n        options: options,\n        styles: getStyles( seed , node , index )\n    };\n}\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar Easing = require( 'shared/easing' );\nvar Bean = require( 'pod/bean' );\n\nmodule.exports = IteratorMOJO;\n\nfunction IteratorMOJO( node , bean ) {\n    var that = this;\n    var bean_options = bean.options;\n    that.bean = bean;\n    that.node = node;\n    that.type = bean.type;\n    that.running = false;\n    that.styles = bean.styles;\n    that.properties = bean.order.computed;\n    that.duration = bean_options.duration;\n    that.delay = bean_options.delay;\n    that.easing = Easing( bean_options.easing );\n    MOJO.Construct( that );\n}\n\nIteratorMOJO.prototype = MOJO.Create({\n    constructor: IteratorMOJO,\n    calculate: function( percent ) {\n        var that = this;\n        helper.each( that.diff , function( diff , key ) {\n            var current = that.current[key];\n            var dest = that.dest[key];\n            diff.forEach(function( val , i ) {\n                var value = val * (1 - percent);\n                if (helper.isNum( val )) {\n                    current[i] = dest[i] - value;\n                }\n                else {\n                    current[i] = (val === current.defaults[i] ? dest[i] : val);\n                }\n            });\n        });\n        that.paint( that.current );\n    },\n    paint: function( model ) {\n        var that = this;\n        var $hx = that.node.$hx;\n        var bean = that._updateBean( model );\n        $hx.updateComponent( bean );\n        $hx.paint( that.type );\n    },\n    resolve: function( model , attached ) {\n        var that = this;\n        if (attached) {\n            that.paint( model );\n        }\n        that.happen( 'beanComplete' , that );\n    },\n    handleMOJO: function( e ) {\n        var that = this;\n        var args = arguments;\n        var progress;\n        switch (e.type) {\n            case 'init':\n                that._init();\n            break;\n            case 'timing':\n                that._timing.apply( that , args );\n            break;\n            case 'progress':\n                progress = args[1];\n                if (!that.running && progress >= 0) {\n                    that.running = true;\n                    that.dispel( 'progress' , that );\n                }\n            break;\n            case 'podCanceled':\n                if (!that.running) {\n                    that.happen( 'beanCanceled' );\n                }\n            break;\n        }\n    },\n    _init: function() {\n        var that = this;\n        var node = that.node;\n        var $hx = node.$hx;\n        var current = that.current = that._getCurrent( node );\n        that.dest = that._getDest( current , that.styles );\n        that.diff = that._getDiff( node , current , that.dest );\n        $hx.deleteTransition( that.type );\n        $hx.applyTransition();\n        that.when( 'progress' , that );\n        that.happen( 'beanStart' );\n    },\n    _timing: function( e , elapsed , diff , attached ) {\n        var that = this;\n        var duration = that.duration;\n        var delay = that.delay;\n        var progress = Bean.Calc( elapsed , duration , delay );\n        if (Bean.CheckTol( progress , 1 , duration , delay )) {\n            progress = 1;\n        }\n        that.happen( 'progress' , progress );\n        if (progress === 1) {\n            that.resolve( that.dest , attached );\n        }\n        else if (attached) {\n            that.calculate(\n                that.easing.function( progress )\n            );\n        }\n    },\n    _updateBean: function( model ) {\n        var that = this;\n        var bean = that.bean;\n        helper.each( model , function( property , key ) {\n            bean.styles[key] = property;\n        });\n        return bean;\n    },\n    _getCurrent: function( node ) {\n        var that = this;\n        var current = {};\n        var type = that.type;\n        var properties = that.properties;\n        properties.forEach(function( property ) {\n            var find = (property === 'value' ? type : property);\n            current[property] = node.$hx.getComponents( find , false );\n        });\n        return current;\n    },\n    _getDest: function( current , styles ) {\n        var that = this;\n        var newProperties = {};\n        helper.each( current , function( CSSProperty , key ) {\n            var clone = CSSProperty.clone();\n            clone.update( styles[key] );\n            newProperties[key] = clone;\n        });\n        return newProperties;\n    },\n    _getDiff: function( node , current , dest ) {\n        var diff = {};\n        helper.each( current , function( property , key ) {\n            diff[key] = property.map(function( val , i ) {\n                return helper.isNum( val ) ? dest[key][i] - val : val;\n            });\n        });\n        return diff;\n    }\n});\n",
    "var AnimationPod = require( 'pod/animationPod' );\nvar PrecisionPod = require( 'pod/precisionPod' );\nvar PromisePod = require( 'pod/promisePod' );\n\nmodule.exports = function PodFactory( node , type ) {\n    switch (type) {\n        case AnimationPod.type:\n            return new AnimationPod( node );\n        case PrecisionPod.type:\n            return new PrecisionPod();\n        case PromisePod.type:\n            return new PromisePod();\n    }\n};\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar SubscriberMOJO = require( 'pod/subscriberMOJO' );\n\nvar TIMING = 'timing';\nvar TIMING_CALLBACK = 'timingCallback';\nvar POD_PAUSED = 'podPaused';\nvar POD_RESUMED = 'podResumed';\nvar POD_COMPLETE = 'podComplete';\nvar POD_CANCELED = 'podCanceled';\nvar POD_FORCED = 'forceResolve';\nvar SUBSCRIBE = 'subscribe';\nvar INIT = 'init';\nvar BEAN_START = 'beanStart';\nvar BEAN_COMPLETE = 'beanComplete';\nvar BEAN_CANCELED = 'beanCanceled';\nvar PROGRESS = 'progress';\n\nmodule.exports = PrecisionPod;\n\nfunction PrecisionPod() {\n    var that = this;\n    that.type = PrecisionPod.type;\n    that.forced = false;\n    that.paused = false;\n    that.buffer = 0;\n    that.attached = true;\n    that[PROGRESS] = [];\n    MOJO.Construct( that );\n    helper.defProps( that , {\n        subscribers: helper.descriptor(function() {\n            return helper.length( that.handlers[ TIMING ] || [] );\n        }),\n        complete: helper.descriptor(function() {\n            return that.subscribers === 0;\n        })\n    });\n    that._init();\n}\n\nPrecisionPod.type = 'precision';\n\nPrecisionPod.prototype = MOJO.Create({\n    constructor: PrecisionPod,\n    _init: function() {\n        var that = this;\n        var subscriber = new SubscriberMOJO();\n        subscriber.when( TIMING , that );\n        that.once([ SUBSCRIBE , POD_COMPLETE , POD_FORCED , POD_CANCELED ] , subscriber , that );\n    },\n    addBean: function( iteratorMOJO ) {\n        var that = this;\n        var index = that.subscribers;\n        that.when( TIMING , iteratorMOJO );\n        that.once([ INIT , POD_CANCELED ] , iteratorMOJO );\n        iteratorMOJO.when( PROGRESS , index , that );\n        iteratorMOJO.once([ BEAN_START , BEAN_COMPLETE , BEAN_CANCELED ] , that );\n    },\n    addCallback: function( callback ) {  \n        var that = this;\n        that.when( TIMING_CALLBACK , function( e , elapsed , diff , attached ) {\n            if (attached) {\n                callback( elapsed , that.progress );\n            }\n        });\n    },\n    run: function() {\n        this.happen([ INIT , SUBSCRIBE ]);\n    },\n    detach: function() {\n        this.attached = false;\n    },\n    pause: function() {\n        var that = this;\n        that.paused = true;\n        that.happen( POD_PAUSED , that );\n    },\n    resume: function() {\n        var that = this;\n        that.paused = false;\n        that.happen( POD_RESUMED , that );\n    },\n    resolvePod: function() {\n        var that = this;\n        if (that.complete) {\n            that.happen( POD_COMPLETE , that );\n        }\n        else {\n            that.happen( POD_FORCED );\n        }\n    },\n    cancel: function() {\n        var that = this;\n        that.happen( POD_CANCELED , that );\n    },\n    handleMOJO: function( e ) {\n        var that = this;\n        var args = arguments;\n        var subscriber, index, progress, iteratorMOJO;\n        switch (e.type) {\n            case TIMING:\n                that._timing.apply( that , args );\n            break;\n            case SUBSCRIBE:\n                subscriber = args[1];\n                subscriber.subscribe();\n            break;\n            case POD_COMPLETE:\n                subscriber = args[1];\n                subscriber.dispel();\n                that.dispel();\n            break;\n            case POD_CANCELED:\n                that.dispel( BEAN_COMPLETE );\n                that.happen( POD_FORCED );\n            break;\n            case POD_FORCED:\n                that.forced = true;\n                subscriber = args[1];\n                if (that.paused || !that.attached) {\n                    that.happen( POD_COMPLETE , that );\n                }\n                else {\n                    that.dispel( null , that );\n                    that.happen( POD_COMPLETE , that );\n                    that.once( POD_COMPLETE , subscriber , that );\n                }\n            break;\n            case PROGRESS:\n                index = args[1];\n                progress = args[2];\n                that[PROGRESS][index] = progress > 1 ? 1 : progress;\n            break;\n            case BEAN_START:\n                iteratorMOJO = e.target;\n                that.happen( BEAN_START, iteratorMOJO.bean );\n            break;\n            case BEAN_CANCELED:\n                iteratorMOJO = e.target;\n                iteratorMOJO.dispel();\n                that.dispel( null , iteratorMOJO );\n            break;\n            case BEAN_COMPLETE:\n                iteratorMOJO = e.target;\n                that.dispel( null , iteratorMOJO );\n                if (!that.forced) {\n                    that.happen( BEAN_COMPLETE , iteratorMOJO.bean );\n                }\n                if (that.complete) {\n                    that.resolvePod();\n                }\n            break;\n        }\n    },\n    _timing: function( e , elapsed , diff ) {\n        var that = this;\n        var attached = that.attached;\n        if (that.paused) {\n            that.buffer += diff;\n        }\n        else {\n            that.happen([ TIMING , TIMING_CALLBACK ] , [( elapsed - that.buffer ) , diff , attached ]);\n        }\n    }\n});\n",
    "var MOJO = require( 'mojo' );\nvar Promise = require( 'wee-promise' );\nvar helper = require( 'shared/helper' );\n\nmodule.exports = PromisePod;\n\nfunction PromisePod() {\n    var that = this;\n    that.type = PromisePod.type;\n    that.attached = true;\n    Promise.call( that );\n    MOJO.Construct( that );\n}\n\nPromisePod.type = 'promise';\n\nPromisePod.prototype = MOJO.Create($.extend( {} , helper.create( Promise.prototype ), {\n    constructor: PromisePod,\n    run: function() {\n        this.resolve();\n    },\n    resolvePod: function() {\n        var that = this;\n        that.happen( 'podComplete' , that );\n    },\n    cancel: function() {\n        var that = this;\n        that.happen( 'podCanceled' , that );\n    },\n    detach: function() {\n        \n    }\n}));\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar TimingMOJO = require( 'pod/timingMOJO' );\n\nvar TIMING = 'timing';\n\nmodule.exports = SubscriberMOJO;\n\nfunction SubscriberMOJO() {\n    var that = this;\n    that.time = null;\n    that.startTime = null;\n    MOJO.Construct( that );\n    helper.defProp( that , 'subscribers' , helper.descriptor(\n        function() {\n            return helper.length( that.handlers[ TIMING ] || [] );\n        }\n    ));\n    that[TIMING] = that[TIMING].bind( that );\n}\n\nSubscriberMOJO.prototype = MOJO.Create({\n    constructor: SubscriberMOJO,\n    timing: function( e , timestamp ) {\n        var that = this;\n        var diff = timestamp - (that.time || timestamp);\n        that.time = timestamp;\n        if (!that.startTime) {\n            that.startTime = timestamp;\n        }\n        var elapsed = timestamp - that.startTime;\n        that.happen( TIMING , [ elapsed , diff ]);\n        if (that.subscribers < 1) {\n            that.destroy();\n        }\n    },\n    subscribe: function() {\n        TimingMOJO.subscribe( this[TIMING] );\n    },\n    destroy: function() {\n        TimingMOJO.unsubscribe( this[TIMING] );\n    }\n});\n",
    "var MOJO = require( 'mojo' );\nvar helper = require( 'shared/helper' );\nvar VendorPatch = require( 'shared/vendorPatch' );\n\nvar TIMING = 'timing';\n\nvar shouldLoop = false;\nvar TimingMOJO = new MOJO({\n    subscribe: function( callback ) {\n        TimingMOJO.when( TIMING , callback );\n        if (!shouldLoop) {\n            start();\n        }\n    },\n    unsubscribe: function( callback ) {\n        TimingMOJO.dispel( TIMING , callback );\n    }\n});\n\nhelper.defProp( TimingMOJO , 'subscribers' , helper.descriptor(\n    function() {\n        return helper.length( TimingMOJO.handlers[ TIMING ] || [] );\n    }\n));\n\nmodule.exports = TimingMOJO;\n\nfunction start() {\n    shouldLoop = true;\n    VendorPatch.RAF( step );\n}\n\nfunction step( timestamp ) {\n    TimingMOJO.happen( TIMING , timestamp );\n    if (!TimingMOJO.subscribers) {\n        shouldLoop = false;\n    }\n    else if (shouldLoop) {\n        VendorPatch.RAF( step );\n    }\n}\n",
    "var BezierEasing = require( 'bezier-easing' );\nvar VendorPatch = require( 'shared/vendorPatch' );\nvar helper = require( 'shared/helper' );\n\nvar UNCLAMPED = VendorPatch.unclamped();\n\nmodule.exports = Bezier;\n\nfunction Bezier( name , points ) {\n    var that = this;\n    var bezier = new BezierEasing( points );\n    Array.call( that );\n    points.forEach(function( point ) {\n        that.push( UNCLAMPED ? point : clamp( point ));\n    });\n    helper.defProps( that , {\n        name: {value: name},\n        string: helper.descriptor(function() {\n            return 'cubic-bezier(' + that.join( ',' ) + ')';\n        }),\n        function: { value: bezier.get },\n    });\n}\n\nBezier.define = function( name , points ) {\n    if (!helper.isUndef( Definitions[name] )) {\n        throw new Error( name + ' is already defined' );\n    }\n    Definitions[name] = new Bezier( name , points );\n    return Definitions[name];\n};\n\nBezier.retrieve = function( name ) {\n    return Definitions[name] || Definitions[ Definitions.default ];\n};\n\nBezier.prototype = helper.create( Array.prototype );\n\nBezier.prototype.constructor = Bezier;\n\nfunction clamp( point ) {\n    return (point < 0 ? 0 : (point > 1 ? 1 : point));\n}\n\nvar Definitions = {\n    default: 'ease'\n};\n",
    "var helper = require( 'shared/helper' );\n\nmodule.exports.buffer = ((1000 / 60) * 2);\n\nmodule.exports.optionKeys = [ 'ref' , 'type' , 'duration' , 'easing' , 'delay' , 'done' , 'order' ];\n\nmodule.exports.properties = (function(){\n    var properties = {};\n    helper.defProps( properties , {\n        inverse: helper.descriptor(function() {\n            var out = {};\n            helper.each( this , function( val , key ) {\n                out[val] = key;\n            });\n            return out;\n        })\n    });\n    return properties;\n}());\n\nmodule.exports.defaults = {\n    ref: null,\n    duration: 400,\n    easing: 'ease',\n    delay: 0,\n    done: function() {}\n};\n",
    "var helper = require( 'shared/helper' );\nvar Bezier = require( 'shared/bezier' );\n\nmodule.exports = function Easing( definition ) {\n    var out;\n    if (helper.is( definition , 'string' )) {\n        out = Bezier.retrieve( definition );\n    }\n    else if (helper.is( definition , 'object' )) {\n        out =  new Bezier( null , definition );\n    }\n    return out;\n};\n",
    "var exports = module.exports;\n\nfunction keys( subject ) {\n    return Object.keys( subject );\n}\n\nfunction each( subject , cb ){\n  if (isArr( subject )) {\n    for (var i = 0; i < length( subject ); i++) {\n      cb( subject[i] , i );\n    }\n  }\n  else if (is( subject , 'object' )) {\n    each(keys( subject ), function( key ){\n      cb( subject[key] , key );\n    });\n  }\n  else if (subject) {\n    cb( subject , 0 );\n  }\n  return subject;\n}\n\nfunction compareArray( subject , array ) {\n    if (!subject || !array) {\n        return false;\n    }\n    if (length( subject ) != length( array )) {\n        return false;\n    }\n    for (var i = 0, l = length( subject ); i < l; i++) {\n        if (isArr( subject[i] ) && isArr( array[i] )) {\n            if (!compareArray( subject[i] , array[i] )) {\n                return false;\n            }\n        }\n        else if (subject[i] !== array[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction length( subject ) {\n    return subject.length;\n}\n\nfunction isArr( subject ) {\n    return instOf( subject , Array );\n}\n\nfunction instOf( subject , constructor ) {\n    return (subject instanceof constructor);\n}\n\nfunction is( subject , type ) {\n    return typeof subject === type;\n}\n\nfunction treeSearch( branch , find ) {\n    for (var key in branch) {\n        if (key === find) {\n            return branch[key];\n        }\n        else if (find in branch[key]) {\n            return treeSearch( branch[key] , find );\n        }\n    }\n}\n\nexports.keys = keys;\nexports.each = each;\nexports.compareArray = compareArray;\nexports.length = length;\nexports.isArr = isArr;\nexports.instOf = instOf;\nexports.is = is;\nexports.treeSearch = treeSearch;\n\nexports.ensureArray = function( subject ) {\n    return (isArr( subject ) ? subject : [ subject ]);\n};\n\nexports.shift = function( subject ) {\n    return Array.prototype.shift.call( subject );\n};\n\nexports.pop = function( subject ) {\n    return Array.prototype.pop.call( subject );\n};\n\nexports.descriptor = function( getter , setter ) {\n    return { get: getter, set: setter };\n};\n\nexports.indexOf = function( subject , search ) {\n    return subject.indexOf( search );\n};\n\nexports.create = function( subject ) {\n    return Object.create( subject );\n};\n\nexports.defProp = function( subject , name , descriptor ) {\n    Object.defineProperty( subject , name , descriptor );\n};\n\nexports.defProps = function( subject , props ) {\n    Object.defineProperties( subject , props );\n};\n\nexports.has = function( subject , key ) {\n    return subject.hasOwnProperty( key );\n};\n\nexports.del = function( subject , key ) {\n    delete subject[key];\n};\n\nexports.isFunc = function( subject ) {\n    return instOf( subject , Function );\n};\n\nexports.isObj = function( subject , strict ) {\n    return strict ? instOf( subject , Object ) : is( subject , 'object' );\n};\n\nexports.isNum = function( subject ) {\n    return !isNaN( subject * 1 );\n};\n\nexports.isNull = function( subject ) {\n    return subject === null;\n};\n\nexports.isUndef = function( subject ) {\n    return is( subject , 'undefined' );\n};\n\nexports.test = function( subject , testval ) {\n    return subject.test( testval );\n};\n",
    "var helper = require( 'shared/helper' );\n\nvar OTHER = 'other';\nvar USER_AGENT = navigator.userAgent;\nvar VENDORS = {\n    webkit  : (/webkit/i),\n    moz     : (/firefox/i),\n    o       : (/opera/i),\n    ms      : (/msie/i)\n};\nvar OS = {\n    android : (/android/i),\n    ios     : (/(ipad|iphone|ipod)/i),\n    macos   : (/mac os/i),\n    windows : (/windows/i)\n};\nvar PREFIX = [\n    (/(?:-[^-]+-)?((?:transform))/g),\n    (/(?:-[^-]+-)?((?:transition))/g),\n    { regx: (/(?:-[^-]+-)?((?:filter))/g), omit: [ 'ms' ]}\n];\n\nvar vendor = UA_RegExp( VENDORS );\nvar os = UA_RegExp( OS );\n\nmodule.exports.unclamped = function() {\n    return isAndroidNative( os ) === false;\n};\n\nmodule.exports.prefix = function( str ) {\n    if (vendor === OTHER) {\n        return str;\n    }\n    PREFIX.forEach(function( pfx ) {\n        var re, omit = [];\n        if (helper.instOf( pfx , RegExp )) {\n            re = pfx;\n        }\n        else {\n            re = pfx.regx;\n            omit = pfx.omit || omit;\n        }\n        if (helper.indexOf( omit , vendor ) < 0) {\n            str = str.replace( re , ( '-' + vendor + '-$1' ));\n        }\n    });\n    return str;\n};\n\nmodule.exports.RAF = (function(){\n    var name = 'equestAnimationFrame';\n    var requestAnimationFrame = (\n        window['r' + name] ||\n        window['webkitR' + name] ||\n        window['mozR' + name] ||\n        window['oR' + name] ||\n        window['msR' + name] ||\n        (function(){\n            var initTime = Date.now();\n            return function( callback ) {\n                var timeout = setTimeout(function() {\n                    callback( Date.now() - initTime );\n                    clearTimeout( timeout );\n                }, ( 1000 / 60 ));\n            };\n        }())\n    );\n    return function( callback ){\n        return requestAnimationFrame( callback );\n    };\n}());\n\nfunction UA_RegExp( search ) {\n    for (var key in search) {\n        if (helper.test( search[key] , USER_AGENT )) {\n            return key;\n        }\n    }\n    return OTHER;\n}\n\nfunction isAndroidNative( os ) {\n    return (os === 'android' && !helper.test( /(chrome|firefox)/i , USER_AGENT ));\n}\n",
    "/**\n * BezierEasing - use bezier curve for transition easing function\n * by Gatan Renaudeau 2014 - 2015  MIT License\n *\n * Credits: is based on Firefox's nsSMILKeySpline.cpp\n * Usage:\n * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\n * spline.get(x) => returns the easing value | x must be in [0, 1] range\n *\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === \"function\";\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) {\n  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) return aGuessT;\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\n\n/**\n * points is an array of [ mX1, mY1, mX2, mY2 ]\n */\nfunction BezierEasing (points, b, c, d) {\n  if (arguments.length === 4) {\n    return new BezierEasing([ points, b, c, d ]);\n  }\n  if (!(this instanceof BezierEasing)) return new BezierEasing(points);\n\n  if (!points || points.length !== 4) {\n    throw new Error(\"BezierEasing: points must contains 4 values\");\n  }\n  for (var i=0; i<4; ++i) {\n    if (typeof points[i] !== \"number\" || isNaN(points[i]) || !isFinite(points[i])) {\n      throw new Error(\"BezierEasing: points should be integers.\");\n    }\n  }\n  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {\n    throw new Error(\"BezierEasing x values must be in [0, 1] range.\");\n  }\n\n  this._str = \"BezierEasing(\"+points+\")\";\n  this._css = \"cubic-bezier(\"+points+\")\";\n  this._p = points;\n  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  this._precomputed = false;\n\n  this.get = this.get.bind(this);\n}\n\nBezierEasing.prototype = {\n\n  get: function (x) {\n    var mX1 = this._p[0],\n      mY1 = this._p[1],\n      mX2 = this._p[2],\n      mY2 = this._p[3];\n    if (!this._precomputed) this._precompute();\n    if (mX1 === mY1 && mX2 === mY2) return x; // linear\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) return 0;\n    if (x === 1) return 1;\n    return calcBezier(this._getTForX(x), mY1, mY2);\n  },\n\n  getPoints: function() {\n    return this._p;\n  },\n\n  toString: function () {\n    return this._str;\n  },\n\n  toCSS: function () {\n    return this._css;\n  },\n\n  // Private part\n\n  _precompute: function () {\n    var mX1 = this._p[0],\n      mY1 = this._p[1],\n      mX2 = this._p[2],\n      mY2 = this._p[3];\n    this._precomputed = true;\n    if (mX1 !== mY1 || mX2 !== mY2)\n      this._calcSampleValues();\n  },\n\n  _calcSampleValues: function () {\n    var mX1 = this._p[0],\n      mX2 = this._p[2];\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  },\n\n  /**\n   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\n   */\n  _getTForX: function (aX) {\n    var mX1 = this._p[0],\n      mX2 = this._p[2],\n      mSampleValues = this._mSampleValues;\n\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n};\n\n// CSS mapping\nBezierEasing.css = {\n  \"ease\":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),\n  \"linear\":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),\n  \"ease-in\":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),\n  \"ease-out\":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),\n  \"ease-in-out\": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)\n};\n\nmodule.exports = BezierEasing;\n",
    "/*! mojo - 0.1.6 - Bernard McManus - strict-hotfix - g727d74 - 2014-10-16 */\nvar _MOJO={},MOJO={};_MOJO.Shared=function(a,b){function c(a){return a.length}function d(b){return a.keys(b)}function e(a){return b.prototype.shift.call(a)}function f(a){return a instanceof b?a:a!==i?[a]:[]}function g(a,b){return{get:a,set:b,configurable:!0}}function h(a){return(a||{})[j]?a[j]:a}var i,j=\"handleMOJO\";return{length:c,keys:d,shift:e,ensureArray:f,descriptor:g,getHandlerFunc:h}}(Object,Array),_MOJO.EventHandler=function(a){function b(a,b,c){var e=this;e.handler=a,e.context=b,e.active=!0,e.callback=function(){},e.args=d(c)}var c=a.Shared,d=c.ensureArray;return b.prototype={invoke:function(a,b){var c=this,e=c.handler;if(c.active&&!a.isBreak&&!a.shouldSkip(e)){var f=c.args.concat(d(b));f.unshift(a),e.apply(c.context,f),c.callback(a,e)}}},b}(_MOJO),_MOJO.Event=function(a,b){function c(b,c){var d=this;d.isBreak=e,d.cancelBubble=e,d.defaultPrevented=e,d.skipHandlers=[],d.target=b,d.type=c,d.timeStamp=a.now()}var d=!0,e=!1,f=b.Shared,g=f.ensureArray,h=f.getHandlerFunc;return c.prototype={skip:function(a){var b=this.skipHandlers;g(a).forEach(function(a){b.push(h(a))})},shouldSkip:function(a){return this.skipHandlers.indexOf(a)>=0},\"break\":function(){this.isBreak=d},preventDefault:function(){this.defaultPrevented=d},stopPropagation:function(){this.cancelBubble=d}},c}(Date,_MOJO),_MOJO.When=function(a,b,c){function d(a,b){return l(a).map(function(a){return a.handler}).indexOf(b)}function e(a,c){(a instanceof b?a:a.split(\" \")).forEach(c)}function f(a,b){return a===b?null:a}var g=c.Shared,h=c.EventHandler,i=c.Event,j=g.keys,k=g.shift,l=g.ensureArray,m=g.length,n=g.getHandlerFunc,o={once:function(){var a=this,b=a._when(arguments);return b.forEach(function(a){a.callback=function(){this.active=!1}}),a},when:function(){var a=this;return a._when(arguments),a},_when:function(a){var b=this,c=k(a),d=m(a)>1?k(a):d,g=[],i=k(a),j=n(i),l=f(i,j);return e(c,function(a,c){g.push(new h(j,l,d)),b._addHandler(a,g[c])}),g},happen:function(a,b){var c=this;return a=c._ensureEType(a),e(a,function(a){var d=c._getHandlers(a,!0),e=new i(c,a);d.filter(function(a){return a.invoke(e,b),!a.active}).forEach(function(b){c._removeHandler(c._getHandlers(a),b.handler)})}),c},dispel:function(a,b){var c=this,d=c._getHandlers(),f=n(b);return a=c._ensureEType(a),e(a,function(a){f?c._removeHandler(d[a],f):delete d[a]}),c},_ensureEType:function(a){return a||j(this._getHandlers()).join(\" \")},_getHandlers:function(b,c){var d=this,e=d.handlers=d.handlers||{},f=b?e[b]=e[b]||[]:e;return c?b?f.slice():a.create(f):f},_addHandler:function(a,b){var c=this;c._getHandlers(a).push(b)},_removeHandler:function(a,b){var c=d(a,b);c>=0&&a.splice(c,1)}};return o}(Object,Array,_MOJO),MOJO=function(a){function b(a){a=a||{};var c=this;b.Each(a,function(a,b){c[b]=a}),b.Construct(c)}var c=b.prototype=Object.create(a.When);return c.each=function(a){var c=this;return b.Each(c,a,c.keys),c},c.set=function(a,b){var c=this;return c[a]=b,c.happen(\"set\",a),c},c.remove=function(a){var b=this;return delete b[a],b.happen(\"remove\",a),b},b}(_MOJO),MOJO.Each=function(a){function b(a,b,c){(c||d(a)).forEach(function(c,d){b(a[c],c,d)})}var c=a.Shared,d=c.keys;return b}(_MOJO),MOJO.Create=function(a,b){function c(c){var d=a.create(b.prototype);return b.Each(c,function(a,b){d[b]=a}),d}return c}(Object,MOJO),MOJO.Construct=function(a,b){function c(b){var c={};a.defineProperties(b,{handlers:{get:function(){return c},set:function(a){c=a},configurable:!0},keys:f(function(){return e(b)}),length:f(function(){return g(b.keys)}),handleMOJO:{value:(b.handleMOJO||function(){}).bind(b),configurable:!0}})}var d=b.Shared,e=d.keys,f=d.descriptor,g=d.length;return c}(Object,_MOJO),function(a){\"object\"==typeof exports?module.exports=a:window.MOJO=a}(MOJO);",
    "/*! wee-promise - 1.0.6 - Bernard McManus - 4a1cdaa - 2016-10-25 */\n\n(function(global,UNDEFINED) {\n\"use strict\";\n\nfunction Stack() {\n\tvar that = this;\n\tthat.q = [];\n\tthat.i = 0;\n\tthat.len = 0;\n}\n\nStack.prototype.put = function(element) {\n\tvar that = this;\n\tthat.q[that.len] = element;\n\tthat.len++;\n};\n\nStack.prototype.get = function() {\n\tvar that = this,\n\t\telement = that.q[that.i];\n\tthat.i++;\n\tif (that.i >= that.len) {\n\t\tthat.q.length = that.i = that.len = 0;\n\t}\n\treturn element;\n};\n\nvar asyncProvider;\n\nif (global.setImmediate) {\n\tasyncProvider = setImmediate;\n} else if (global.MessageChannel) {\n\tasyncProvider = (function() {\n\t\tvar stack = new Stack(),\n\t\t\tchannel = new MessageChannel();\n\t\tchannel.port1.onmessage = function() {\n\t\t\t/* jshint -W084 */\n\t\t\tvar fn;\n\t\t\twhile (fn = stack.get()) {\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(cb) {\n\t\t\tstack.put(cb);\n\t\t\tchannel.port2.postMessage(0);\n\t\t};\n\t}());\n} else {\n\tasyncProvider = setTimeout;\n}\n\nWeePromise.async = function(cb) {\n\tasyncProvider(cb);\n};\n\n\nvar PENDING = 0;\nvar RESOLVED = 1;\nvar REJECTED = 2;\n\nfunction WeePromise(resolver) {\n\tvar that = this;\n\tvar one = getSingleCallable(function(action, value) {\n\t\taction(that, value);\n\t});\n\n\tthat._state = PENDING;\n\tthat._stack = new Stack();\n\tthat.resolve = function(value) {\n\t\tone($resolve, value);\n\t\treturn that;\n\t};\n\tthat.reject = function(reason) {\n\t\tone($reject, reason);\n\t\treturn that;\n\t};\n\n\tif (resolver) {\n\t\ttry {\n\t\t\tresolver(that.resolve, that.reject);\n\t\t}\n\t\tcatch(err) {\n\t\t\tthat.reject(err);\n\t\t}\n\t}\n}\n\nWeePromise.prototype.onresolved = function(value) {\n\treturn value;\n};\n\nWeePromise.prototype.onrejected = function(reason) {\n\tthrow reason;\n};\n\nWeePromise.prototype._flush = function() {\n\tvar that = this;\n\tvar state = that._state;\n\n\tif (state) {\n\t\tWeePromise.async(function() {\n\t\t\t(function flush() {\n\t\t\t\tvar promise = that._stack.get();\n\t\t\t\tif (promise) {\n\t\t\t\t\tvar fn = (state === RESOLVED ? promise.onresolved : promise.onrejected);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$resolve(promise, fn(that._value));\n\t\t\t\t\t}\n\t\t\t\t\tcatch(err) {\n\t\t\t\t\t\t$reject(promise, err);\n\t\t\t\t\t}\n\t\t\t\t\tflush();\n\t\t\t\t}\n\t\t\t}());\n\t\t});\n\t}\n};\n\nWeePromise.prototype.then = function(onresolved, onrejected) {\n\tvar that = this;\n\tvar promise = new WeePromise();\n\n\tif (isFunction(onresolved)) {\n\t\tpromise.onresolved = onresolved;\n\t}\n\tif (isFunction(onrejected)) {\n\t\tpromise.onrejected = onrejected;\n\t}\n\n\tthat._stack.put(promise);\n\tthat._flush();\n\treturn promise;\n};\n\nWeePromise.prototype.catch = function(onrejected) {\n\treturn this.then(UNDEFINED, onrejected);\n};\n\nWeePromise.resolve = function(result) {\n\treturn new WeePromise().resolve(result);\n};\n\nWeePromise.reject = function(reason) {\n\treturn new WeePromise().reject(reason);\n};\n\nWeePromise.all = function(collection) {\n\tvar promise = new WeePromise();\n\tvar result = [];\n\tvar got = 0;\n\tvar need = collection.length;\n\n\tcollection.forEach(function(child, i) {\n\t\tunwrap(child, function(state, value) {\n\t\t\tgot++;\n\t\t\tresult[i] = value;\n\t\t\tif (state === REJECTED) {\n\t\t\t\tpromise.reject(value);\n\t\t\t} else if (got === need) {\n\t\t\t\tpromise.resolve(result);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn promise;\n};\n\nWeePromise.race = function(collection) {\n\tvar promise = new WeePromise();\n\tcollection.forEach(function(child) {\n\t\tunwrap(child, function(state, value) {\n\t\t\tsetState(promise, state, value);\n\t\t});\n\t});\n\treturn promise;\n};\n\nfunction $resolve(context, value) {\n\tif (value === context) {\n\t\t$reject(context, new TypeError('A promise cannot be resolved with itself.'));\n\t} else {\n\t\tunwrap(value, function(state, value) {\n\t\t\tsetState(context, state, value);\n\t\t});\n\t}\n}\n\nfunction $reject(context, reason) {\n\tsetState(context, REJECTED, reason);\n}\n\nfunction setState(context, state, value) {\n\tif (context._state != state) {\n\t\tcontext._value = value;\n\t\tcontext._state = state;\n\t\tcontext._flush();\n\t}\n}\n\nfunction unwrap(value, cb) {\n\tif (value instanceof WeePromise && value._state) {\n\t\t// non-pending WeePromise instances\n\t\tcb(value._state, value._value);\n\t} else if (isObject(value) || isFunction(value)) {\n\t\t// objects and functions\n\t\tvar then;\n\t\tvar one = getSingleCallable(function(fn, args) {\n\t\t\tfn.apply(UNDEFINED, args);\n\t\t});\n\t\ttry {\n\t\t\tthen = value.then;\n\t\t\tif (isFunction(then)) {\n\t\t\t\tthen.call(value,\n\t\t\t\t\tfunction(_value) {\n\t\t\t\t\t\tone(unwrap, [_value, cb]);\n\t\t\t\t\t},\n\t\t\t\t\tfunction(_reason) {\n\t\t\t\t\t\tone(cb, [REJECTED, _reason]);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tone(cb, [RESOLVED, value]);\n\t\t\t}\n\t\t}\n\t\tcatch(err) {\n\t\t\tone(cb, [REJECTED, err]);\n\t\t}\n\t} else {\n\t\t// all other values\n\t\tcb(RESOLVED, value);\n\t}\n}\n\nfunction getSingleCallable(cb) {\n\tvar called;\n\treturn function() {\n\t\tif (!called) {\n\t\t\tcb.apply(UNDEFINED, arguments);\n\t\t\tcalled = true;\n\t\t}\n\t};\n}\n\nfunction isObject(subject) {\n\treturn subject && typeof subject === 'object';\n}\n\nfunction isFunction(subject) {\n\treturn typeof subject === 'function';\n}\n\nif (typeof exports == \"object\") {\nmodule.exports = WeePromise;\n} else {\nglobal.WeePromise = WeePromise;\n}\n}(typeof window==\"object\"?window:global));"
  ]
}